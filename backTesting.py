import os
import math
import requests
import json
import h5py
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pandas_datareader import data
from datetime import datetime
from collections import abc

YAHOO_API_KEY = os.environ.get('YAHOO_FINANCE_API_KEY')
TRADE_DAYS = 252  # Number of trading days
YAHOO_API_URL = "https://yfapi.net/v8/finance/spark"

QUERY = {
    "symbols": None,
    "interval": "1m",
    "range": "1d"}

HEADERS = {'x-api-key': YAHOO_API_KEY}


def dataframe_from_dict(d: dict):
    """Creating pandas dataframe from dictionary.
    Wrapper for pd.DataFrame.from_dict for dictionaries with metadata, which will propogate singleton key value pairs
    across full dataframe. Uses dataframe attrs, which is for metadata, but still experimental"""

    df = pd.DataFrame.from_dict(d)

    for key, value in d.items():
        if not isinstance(value, abc.Iterable) or isinstance(value, str):
            df.drop(columns=key, inplace=True)
            df.attrs[key] = value

    return df


def get_historical_data(stocks):

    now = datetime.now()
    filename = "data_" + now.strftime("%d_%b_%Y") + '.hdf5'

    with h5py.File(filename, 'a') as f:
        saved_keys = list(f.keys())
        print(saved_keys)

    dfs = {s: pd.read_hdf(filename, key=s) for s in stocks if s in saved_keys}
    stocks = [s for s in stocks if s not in dfs.keys()]

    if stocks:
        content = yahoo_api_call(stocks)
        for stock, data in content.items():
            data['timestamp'] = pd.to_datetime(data['timestamp'], unit='s')
            df = dataframe_from_dict(data)
            df.set_index('timestamp', inplace=True)
            dfs[stock] = df

            df.to_hdf(filename, key=stock, mode='a')

    return dfs


def yahoo_api_call(stocks: abc.Iterable):

    QUERY['symbols'] = ','.join(stocks)
    response = requests.request("GET", YAHOO_API_URL, headers=HEADERS, params=QUERY)
    content = json.loads(response.content.decode('utf-8'))

    return content


def main(n):
    # TODO: Make similar function to model day trading
    # download Apple price data into DataFrame
    apple = data.DataReader('AAPL', 'yahoo', start='1/1/2000')
    # calculate the compound annual growth rate (CAGR) which
    # will give us our mean return input (mu)
    days = (apple.index[-1] - apple.index[0]).days
    cagr = (((apple['Adj Close'][-1]) / apple['Adj Close'][1]) ** (365.0 / days)) - 1
    print('CAGR =', str(round(cagr, 4) * 100) + "%")
    mu = cagr  # Return
    mu = 0
    # create a series of percentage returns and calculate
    # the annual volatility of returns
    apple['Returns'] = apple['Adj Close'].pct_change()
    vol = apple['Returns'].std() * math.sqrt(TRADE_DAYS)  # Volatility
    print("Annual Volatility =", str(round(vol, 4) * 100) + "%")

    stock_start = apple['Adj Close'][-1]  # starting stock price (i.e. last available real stock price)

    # set up empty list to hold our ending values for each simulated price series
    result = []
    profits = []

    for i in range(n):

        opened_at = None
        profit = 0

        # create list of daily returns using random normal distribution
        daily_returns = np.random.normal(mu / TRADE_DAYS, vol / math.sqrt(TRADE_DAYS), TRADE_DAYS) + 1

        # set starting price and create price series generated by above random daily returns
        prices = [{'time': datetime.now(), 'price': stock_start}]

        for x in daily_returns:
            opened_at, profit = strategy(prices, opened_at, profit)
            prices.append({'time': datetime.now(), 'price': prices[-1]['price'] * x})
        # plot data from each individual run which we will plot at the end
        plt.plot([p['price'] for p in prices])
        # append the ending value of each simulated run to the empty list we created at the beginning
        result.append(prices[-1])
        profits.append(profit)
    # show the plot of multiple price series created above
    plt.show()

    # use numpy mean function to calculate the mean of the result
    # print(round(np.mean(result), 2))
    # print("5% quantile =", np.percentile(result, 5))
    # print("95% quantile =", np.percentile(result, 95))

    print("Average profit/loss =", round(np.mean(profits), 2))
    print("5% quantile =", np.percentile(profits, 5))
    print("95% quantile =", np.percentile(profits, 95))

    # create histogram of ending stock values for our multiple simulations
    # plt.hist(result, bins=100)
    # plt.axvline(np.percentile(result, 5), color='r', linestyle='dashed', linewidth=2)
    # plt.axvline(np.percentile(result, 95), color='r', linestyle='dashed', linewidth=2)
    # plt.show()

    return result


def feed_historical_data(data: pd.DataFrame):

    lookback_period = 5
    opened_at = None
    profit = 0
    for window in data.rolling(window=lookback_period):
        opened_at, profit = strategy(window['close'], lookback_period, opened_at, profit)

    return profit


def pseudo_data():
    pass


def strategy(price_list, lookback_period, opened_at=None, profit=None):
    # TODO: Have dict input params
    investment = 10
    # Change required to enter, profit and loss stops, defined by percentages
    entry = 0.002  # Percentage increase required to buy
    profit_stop = 0.001
    loss_stop = -0.0015

    if len(price_list) >= lookback_period:

        lookback_prices = price_list.to_numpy()
        change = pct_change(lookback_prices)

        # TODO: cumprod(pct_change + 1) - 1 used here for some reason?
        if opened_at is None:

            if sum(change) > entry:

                opened_at = price_list[-1]
        else:
            prices = np.array([opened_at, price_list[-1]])
            change_since_buy = pct_change(prices)

            if change_since_buy[0] > profit_stop or change_since_buy[0] < loss_stop:

                profit += change_since_buy * investment
                opened_at = None

    return opened_at, profit


def pct_change(data: np.array):

    if len(data) == 1:
        out = 0
    else:
        out = (data[1:] - data[:-1])/data[:-1]

    return out


if __name__ == "__main__":

    # n = 10000
    # main(n)
    input_stocks = ["AAPL", "BTC-USD", "EURUSD=X", "F"]
    dfs = get_historical_data(input_stocks)

    profits = [feed_historical_data(df) for _, df in dfs.items()]
    print(profits)
